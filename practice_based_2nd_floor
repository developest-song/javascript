변수
- 비교 : let const (ES6부터 생긴 것) var (이전 것)

var는 한번 선언된 변수를 다시 선언할 수 있다.
var name = 'Mike';
console.log(name); // Mike
var name = 'Jane';
console.log(name); // Jane

let은 한번 선언된 변수를 다시 선언할 수 없다.
let name = 'Mike';
console.log(name); // Mike
let name = 'Jane';
console.log(name); // Jane




호이스팅 - 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동
console.log(name); // undefined (선언은 호이스팅 되지만 할당은 호이스팅 되지 않음)
var name; // 호이스팅 가능

console.log(name); // ReferenceError
let name; // TDZ(Temporal Dead Zone) 때문에 

let, const는 TDZ에 영향을 받는다
할당하기 전에 사용할 수 없다. -> 코드를 예측가능하게 하고, 잠재적인 버그를 줄임

let age =30;
function showAge(){
  console.log(age); // 호이스팅을 일으키나 TDZ의 영향을 받아 error
  let age=20; // 만약 호이스팅을 일으키지 않았으면 외부 age를 받아서 찍었을 것
}
showAge();



var
1. 선언 및 초기화 단계
2. 할당 단계

let
1. 선언 단계
2. 초기화 단계
3. 할당 단계

const
1. 선언 + 초기화 + 할당

ex)
let name;
name = 'mike';

var age;
age = 30;

const gender; // error 할당하지 않아서
gender = 'male';



var  함수 스코프 - 함수 밖에서 사용 불가
let, const 블록 스코프 - (함수, if문, for문, while문, try/catch문 등) 밖에서 사용 불가



생성자 함수
function Item(title, price){ // 첫 글자를 대문자로 하여금 생성자 함수라 나타냄
  // this = {};
  this.title = title;
  this.price = price;
  this.showPrice = function(){
    console.log(`가격은 ${price}원 입니다`);
  }
  // return this;
}

const item1 = new Item('인형', 3000); // new를 붙여서 만듬
const item2 = new Item('가방', 4000);
const item3 = new Item('지갑', 5000);

console.log(item1, item2, item3);

item3.showPrice(); 




computed property(계산된 프로퍼티)
let n = "name";
let a = "age";

const user = {
  [n] : "Mike", // n의 값이 들어감
  [a] : 30,
  [1 + 4]:5
}
console.log(user);



function makeObj(key, val){
  return {
    [key] : val
  }
}

const obj = makeObj('나이',33); // 어떤 것을 key로 사용할지 모를 때도 사용
console.log(obj);



객체 메소드 
const user = {
  name:'Mike',
  age:30,
}

const user2 = Object.assign({}, user); // 객체 복사 deep copy 개념
                                        // {} 초기값 -> gender:"male" 같은것 추가 가능, 
                                        // Object.assign(user, info1, info2) 해서 하나의 객체로 합치는 것 가능
console.log(user2);

const result = Object.keys(user); // key값을 배열로 return
console.log(result);

const result2 = Object.values(user); // value값을 배열로 return
console.log(result2);

const result3 = Object.entries(user); // key, value를 한 묶음으로 배열로 return -> 이중배열
console.log(result3);



let arr = [
  ['mon', '월'],
  ['tue','화']
]

const result = Object.fromEntries(arr); // 배열로 객체 만드는 메소드
console.log(result);

심볼 ( 자료형 )*********
const a = Symbol(); // new를 붙이지 않습니다.
const b = Symbol(); // 유일한 식별자

console.log(a) 
console.log(b)

a===b // false
a==b // false

Symbol : 유일성 보장

  property key : 심볼형
const id = Symbol('id'); // id는 설명을 붙여줄 수 있음 

const user = {
  name : 'mike',
  age : 30,
  [id] : 'myid' // computed property 
}

console.log(user); // Symbol(id): "myid"도 같이 찍힘 ??? **

const result = Object.keys(user); // symbol없이 name, age만 찍힘 
const result2 = Object.values(user); // symbol없이 mike, 30만 찍힘
const result3 = Object.entries(user); // symbol없이 key, value만 찍힘
for(let a in user){} // 위와 같이 symbol 안찍힘 

\\\\\\\\\\\\\\\\\\\
const user = {
  name : 'mike',
  age : 30,
}

const id = Symbol('id');
user[id] = 'myid'; // 특정 개체에 원본데이터를 건드리지 않고 Symbol로써 속성을 추가할 수 있음
\\\\\\\\\\\\\\\\\\\\\\\\
Symbol.for() : 전역 심볼
하나의 심볼만 보장받을 수 있음
없으면 만들고 있으면 가져오기 때문에
Symbol 함수는 매번 다른 Symbol 값을 생성하지만, 
Symbol.for 메소드는 하나의 생성한 뒤 키를 통해 같은 Symbol을 공유

const id1 = Symbol.for('id');
const id2 = Symbol.for('id'); // id === id2; <- true

Symbol.keyFor(id1) // 이름을 알려줌, 전역 심볼만 사용가능

const id = Symbol('id 입니다');
id.description; // Symbol의 이름 id 입니다

Object.getOwnPropertySymbols(user); // 심볼 키만 보여줌
Reflect.ownKeys(user); // 심볼 키를 포함한 모든 키를 보여줌
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

// 다른 개발자가 만들어 놓은 객체
const user = {
  name : 'mike',
  age : 30,
}
//내가 작업
//user.showName = function(){}; // 밑에 for 구문에 영향이 가는 부분
const showName = Symbol('show name'); // 심볼을 선언하고
user[showName] = function(){ // 심볼을 이용해 심볼 키를 만듬
  console.log(this.name);
}

user[showName](); // this.name으로 mike가 정상적으로 출력됨

// 사용자가 접속하면 보는 메세지
for (let key in user){ // 심볼로 만들어진 키는 for에는 걸리지 않기 때문에 정상적으로 출력
  console.log(`His ${key} is ${user[key]}.`);
}

 Number, Math
let num = 10;
num.toString(); // 그냥 문자로 변환 '10'
num.toString(2); // 2진수로 변환 '1010'

let num2 = 255;
num2.toString(16); // 16진수로 변환 'ff'

Math.PI; // 3.141592653589793

Math.ceil() // 올림
Math.floor() // 내림
Math.round() // 반올림

let userRate = 30.1234;

Math.round(userRate * 100) / 100 // 30.12 숫자반환
userRate.toFixed(2); // '30.12' 문자반환
Number(userRate.toFixed(2)); // 30.12

isNaN()
let x = Number('x'); //NaN

console.log(x); // NaN
console.log(isNaN(x)); // true
NaN은 isNaN으로만 확인 가능   NaN == NaN // false

parseInt()
let margin = '10px';
console.log(parseInt(margin)); // 10
처음부터 읽을 수 있는 곳까지 읽고 숫자로 반환
처음부터 문자일경우 NaN반환

let redColor = 'f3';
parseInt(redColor,16) // 243 .. 16진수 -> 10진수

parseInt('11',2) // 3 .. 2진수 -> 10진수

parseFloat()
let padding = '18.5%';
parseInt(padding) // 18
parseFloat(padding) // 18.5

Math.random() 0~1랜덤 수
Math.floor(Math.random()*100)+1 // 1~100 랜덤 수

Math.max() / Math.min() 
괄호 안의 인수 중 최대 최소 값

Math.abs() 절대값

Math.pow(n,m) 거듭제곱 값 

Math.sqrt() 제곱근

String (문자열)
',",`
let desc = `오늘은
맑고
화창한 날씨다` // error 없이 여러줄 그대로 표현가능

let desc = 'Nice to meet you';
console.log(desc.length); // 16
console.log(desc[0]); // N
console.log(desc.toUpperCase()); // NICE TO MEET YOU
console.log(desc.toLowerCase()); // nice to meet you
console.log(desc.indexOf('to')); // 5 / 없으면 -1 여러개 중 첫번째만 반환
//desc.slice(n, m) // n부터 m(포함x)전까지 음수의 경우 끝에서부터 생략 시 문자열 끝까지
console.log(desc.slice(5,6)) // t
console.log(desc.slice(8,-2)) // meet y
console.log(desc.substring(1,3)) // ic 1부터 3전까지 
console.log(desc.substring(3,1)) // ic 위와 같은 의미
console.log(desc.substr(1,3)) // ice 1부터 3개 가져옴
console.log(desc.substr(-8,3)) // mee -8부터 3개 가져옴

desc.trim(); // 앞 뒤 공백 제거
//desc.repeat(n); // 문자열 n번 반복

console.log('a'.codePointAt(0)); // 97 ASCII
console.log(String.fromCodePoint(97)); // a

ASCII에 따라 문자도 크기 비교 가능 // 소문자가 대문자보다 크다.

ex)
let list = [ 
  "01.a",
  "02.b",
  "03.c",
  "04.d",
  "05.e",
]

let newList = [];
for(let i=0;i<list.length; i++){
  newList.push(
    list[i].slice(3)
  )
}
console.log(newList);

ex2)
// 금칙어 : 콜라

function hasCola(str){
  if(str.indexOf('콜라') > -1){  // str.includes("콜라") 같은 의미로 쓰일 수 있음
    console.log('금칙어가 있습니다.')
  }else{
    console.log('통과')
  }
}
hasCola("와 사이다가 짱이야"); // -1
hasCola("무슨소리, 콜라가 최고");
hasCola("콜라");

Array
// arr.splice(n, m, x) : n부터 m개 지움 그리고 x 추가(생략가능)
let arr = [1,2,3,4,5]
let result = arr.splice(1,3,100,200) 
console.log(arr); // [1,100,200,5]
console.log(result) // arr.splice() : 삭제된 요소 반환
// m에 0이 올 경우 삭제하지 않고 n앞자리 부터 추가 가능

let arr = [1,2,3,4,5];
arr.slice(1,4); // [2,3,4] // 1부터 4전까지 string.slice와 동일

let arr2 = arr.slice(); // slice 빈칸
console.log(arr2); // [1,2,3,4,5] 

let arr = [1,2];
console.log(arr.concat([3,4])); // [1,2,3,4]
console.log(arr.concat([3,4],[5,6])); // [1,2,3,4,5,6]
console.log(arr.concat([3,4],5,6)); // [1,2,3,4,5,6]

// arr.forEach(fn) : 배열 반복

let arr = ['Mike', 'Tom', 'Jane']

arr.forEach((name, index, arr) => {
  console.log(`${index+1}. ${name}. ${arr}`);
});

// arr.indexOf / arr.lastIndexOf

let arr = [1,2,3,4,5,1,2,3]
arr.indexOf(3); // 2
arr.indexOf(3,4); // 7 / 2번째 인수부터 탐색
arr.lastIndexOf(3); // 7

// arr.includes() : 포함하는지 확인 / 있으면 true 없으면 false 반환

// arr.find(fn) / arr.findIndex(fn) 조금 더 복잡하게 함수 포함하여 가능
// *첫번쨰 true 값만 반환하고 끝 만약 없으면 undefined를 반환
ex)
let arr = [1,2,3,4,5];

const result = arr.find((item) => { // find -> arr.filter(fn) 바꿀 시 1개 말고 전부 반환
  return item % 2 === 0
});

console.log(result); // 2

ex)
let userList = [
  { name : 'Mike', age:30},
  { name : 'Jane', age:27},
  { name : 'Tom', age:10},
  { name : 'Lee', age:15}, // true 1개만 반환 하기 때문에 이 객체는 반환되지 않음
]

const result = userList.find((user) => {  // findIndex로 대체 시 index 2를 반환
  if(user.age < 19){
    return true 
  } 
  return false
})

console.log(result); // Tom 객체 return

arr.reverse() 역 순으로 재정렬 

***** arr.map(fn) 함수를 받아 특정 기능을 시행하고 새로운 배열을 반환 *****
let userList = [
  { name : 'Mike', age:30},
  { name : 'Jane', age:27},
  { name : 'Tom', age:10},
]

let newUserList = userList.map((user,index)=>{
  return Object.assign({}, user, {
    id: index + 1,
    isAdult: user.age > 19,
  })
})

console.log(newUserList);

//join, split
ex)
let arr = ['안녕','나는','철수야']

let result = arr.join(' ');
console.log(result); // "안녕 나는 철수야"

ex)
const users = 'mike,jane,tom,tony'

const result = users.split(',');
console.log(result); // ["mike","jane","tom","tony"]
           
Array.isArray()
let user = {
  name:'Mike',
  age: 30,
}

let userList = ['Mike','Tom','Jane']

console.log(typeof user) // object
console.log(typeof userList) // object

console.log(Array.isArray(user)) // false
console.log(Array.isArray(userList)) //true

52:30
