Math.pow(3,2);     //9
Math.round(10.6);  //11
Math.ceil(10.2);   //11
Math.floor(10.6);  //10
Math.sqrt(9);      //3
Math.random();     //0 ~ 1.0의 random 

alert("codinge everybody");

alert(typeof "1")                 // string
alert(typeof 1)                   // number

alert('egoing\'s javascript')     // 이스케이프
alert("coding" + " everybody")

alert("coding".length)            // 6

var first = "coding";
alert(first+" everybody");
JavaScript에서는 세미콜론 생략 가능, 이 경우 줄바꿈을 명령의 끝으로 간주

대입 = / 동등 ==
일치 연산자 === (정확하게 값이 같다)
alert(1==='1');            //false
alert(null == undefined);  //true
alert(null === undefined);  //false
null - 값이 없음 / undefined - 값이 없는 상태

!== (정확하게 같지 않다)

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
</head>
<body>
    <script> // js로 작성
        id = prompt('아이디를 입력해주세요.') // 입력받는 창
        if(id=='egoing'){
            alert('아이디가 일치 합니다.')
        } else {
            alert('아이디가 일치하지 않습니다.')
        }
    </script>
</body>
</html>

논리 연산자 
&& || !

false : 0       true : 1

false로 간주되는 데이터형
'' undefined 초기화안된 변수(a) null NaN
if(!''){ 
    alert('빈 문자열')
}
if(!undefined){
    alert('undefined');
}
var a;
if(!a){
    alert('값이 할당되지 않은 변수'); 
}
if(!null){
    alert('null');
}
if(!NaN){
    alert('NaN');
}


var i = 0;
// 종료조건으로 i의 값이 10보다 작다면 true, 같거나 크다면 false가 된다.
while(i < 10){
    // 반복이 실행될 때마다 coding everybody <br />이 출력된다. <br /> 줄바꿈을 의미하는 HTML 태그
    console.log('coding everybody <br />');
    // i의 값이 1씩 증가한다.
    i++
}

for(var i = 0; i < 10; i++){
    console.log('coding everybody'+i+'<br />');
}; 


break;  // 중단
continue; // 해당 값 범위 빼고 지속

// 0부터 9까지 변수 i에 순차적으로 값을 할당        
for(var i = 0; i < 10; i++){
    // 0부터 9까지의 변수를 j의 값에 순차적으로 할당
    for(var j = 0; j < 10; j++){    
        // i와 j의 값을 더한 후에 출력
        // String은 숫자인 i와 j의 데이터 타입을 문자로 형태를 변환하는 명령이다. 
        console.log(String(i)+String(j)+'<br />');
    }
}

함수
function get_member1(){
    return 'egoing';
}
 
alert(get_member1());

** 같은 함수의 다른 정의 방법
var numbering = function (){
    i = 0;
    while(i < 10){
        console.log(i);
        i += 1;
    }   
}
numbering();


function numbering(){
    i = 0;
    while(i < 10){
        console.log(i);
        i += 1;
    }   
}
numbering();

배열
var member = ['egoing', 'k8805', 'sorialgi']
alert(member[0]); //egoing


// 동일
var members = function(){
    return ['egoing', 'k8805', 'sorialgi'];
}

console.log(members()[0]);
console.log(members()[1]);
console.log(members()[2]);

function get_members(){
    return ['egoing', 'k8805', 'sorialgi'];
}
var members = get_members();
console.log(members[0]);
console.log(members[1]);
console.log(members[2]);

function get_members(){
    return ['egoing', 'k8805', 'sorialgi'];
}
members = get_members();
// members.length는 배열에 담긴 값의 개수를 알려준다. 
for(i = 0; i < members.length; i++){
    // members[i].toUpperCase()는 members[i]에 담긴 문자를 대문자로 변환해준다.
    console.log(members[i].toUpperCase());   
    console.log('<br />');
}

var li = ['a', 'b', 'c', 'd', 'e']; // a b c d e f
li.push('f');
alert(li);

var li = ['a', 'b', 'c', 'd', 'e']; // a b c d e f g
li = li.concat(['f', 'g']);
alert(li);

var li = ['a', 'b', 'c', 'd', 'e']; // z a b c d e
li.unshift('z');
alert(li);

var li = ['a', 'b', 'c', 'd', 'e']; // a b B c d e
li.splice(2, 0, 'B');
alert(li);

var li = ['a', 'b', 'c', 'd', 'e']; // b c d e
li.shift();
alert(li);

var li = ['a', 'b', 'c', 'd', 'e']; // a b c d
li.pop();
alert(li);

var li = ['c', 'e', 'a', 'b', 'd']; // a b c d e
li.sort();
alert(li);

var li = ['c', 'e', 'a', 'b', 'd']; // d b a e c
li.reverse();
alert(li);

객체
var grades = {}; // new Object();
grades['egoing'] = 10;
grades['k8805'] = 6;
grades['sorialgi'] = 80;

var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};
alert(grades['sorialgi']);
alert(grades.k8805);

var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};
for(key in grades) {
    document.write("key : "+key+" value : "+grades[key]+"<br />");
}

var grades = {
    'list': {'egoing': 10, 'k8805': 6, 'sorialgi': 80},
    'show' : function(){
        for(var name in this.list){
            document.write(name+':'+this.list[name]+"<br />");
        }
    }
};
grades.show();

모듈
순수 Javascript는 모듈이라는 개념이 분명하게 존재하지 않지만, 호스트 환경에 따라 다른 모듈화 방법이 제공된다.

- greeting.js
function welcome(){
    return 'Hello world';
}

- main.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <script src="greeting.js"></script> // js파일 다운로드
</head>
<body>
    <script>
        alert(welcome()); //js파일의 function
    </script>
</body>
</html>

node.js에서의 모듈 

- node.circle.js
var PI = Math.PI;
  
exports.area = function (r) { //area function exports
return PI * r * r;
};
  
exports.circumference = function (r) { //circumference function exports
return 2 * PI * r;
};

node.demo.js
var circle = require('./node.circle.js'); //import node.circle.js -> circle
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4)); // 적용

정규 표현식

var pattern = /a/
var pattern = new RegExp('a'); // 위와 같은 결과

// String Return 
console.log(pattern.exec('abcdef')); // ["a"]
console.log(pattern.exec('bcdefg')); // null

// Boolean Return
console.log(pattern.test('abcdef')); // true
console.log(pattern.test('bcdefg')); // false

console.log('abcdef'.match(pattern)); // ["a"]
console.log('bcdefg'.match(pattern)); // null

console.log('abcdef'.replace(pattern, 'A')); // Abcdef
           
패턴
- i : 대소문자 구분하지 않는 패턴 return
var xi = /a/;
console.log("Abcde".match(xi)); // null
var oi = /a/i;
console.log("Abcde".match(oi)); // ["A"]; 

- g : 검색된 모든 개수의 패턴을 return
var xg = /a/;
console.log("abcdea".match(xg)); // ["a"]
var og = /a/g;
console.log("abcdea".match(og)); // ["a","a"]

-m (multi line) : 여러 줄을 검사하는 플래그 문자


캡처
var pattern = /(\w+)\s(\w+)/;
var str = "coding everybody";
var result = str.replace(pattern, "$2, $1"); // 2번째 group, 1번쨰 group
console.log(result);

// \w 문자 A~Z a~z 0~9
// \s 공백문자
// \d 숫자
// \W \S \D 해당 문자들빼고 다 
// + (수량자) 하나 이상의
// ^시작 $끝부분 
// a|b a또는 b
https://regexper.com/ 패턴을 그림으로 표현
https://regexr.com/   패턴과 String이 match되는지 확인해줌

\b(?:https?):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*
\b word boundary (띄어쓰기 기준으 단어 구분자)
(?:https?) - (?:xx) 그룹 검색, s? s가 올수도 안올수도, ://, [a-z0-9-+&@#\/%?=~_|!:,.;]* 0개이상

스코프
var vscope = 'global';
function fscope(){
  var vscope = 'local' // * var를 붙이지 않으면 전역변수가 된다. 
  console.log(`함수안 ${vscope}`); // 지역변수 호출
}

fscope();
console.log(`함수밖 ${vscope}`); // 전역변수 호출

// 불가피하게 전역변수를 사용할 경우 객츼 속성 관리하는 방법
MYAPP = {}
MYAPP.calculator ={
  'left' : null,
  'right' : null
}

MYAPP.coordinate = {
  'left' : null,
  'right' : null
}

MYAPP.calculator.left = 10;
MYAPP.calculator.right = 20;
function sum(){
  return MYAPP.calculator.left + MYAPP.calculator.right;
}

console.log(sum());

렉시컬 스코프
var i = 5;
function a(){
  var i = 10;
  b();
}

function b(){
  console.log(i);
}

a();

값으로서의 함수
js의 함수가 다른 언어의 함수와 다른 점은 함수가 값이 될 수 있다는 점
function cal(func, num){
  return func(num)
}
function increase(num){
    return num+1
}
function decrease(num){
    return num-1
}
alert(cal(increase, 1)); // cal 에 increase, 1 전달   increase() 호출
alert(cal(decrease, 1));

// 함수를 함수의 리턴 값으로 사용 
function cal(mode){
    var funcs = {
        'plus' : function(left, right){return left + right},
        'minus' : function(left, right){return left - right}
    }
    return funcs[mode];
}
console.log(cal('plus')(2,1));
console.log(cal('minus')(2,1));   

// 배열의 값으로 사용
var process = [
    function(input){ return input + 10;},
    function(input){ return input * input;},
    function(input){ return input / 2;}
];
var input = 1;
for(var i = 0; i < process.length; i++){
    input = process[i](input);
}
console.log(input);

콜백

function sortNumber(a,b){
  return b-a; // 내림차순정렬
}

let numbers = [20,10,9,8,7,6,5,4,3,2,1];
console.log(numbers.sort(sortNumber)); 

비동기 처리 
특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성

console.log('Hello') // 1

setTimeout(function(){ // 3
  console.log('Bye')
}, 3000)

console.log('Hello Again') // 2
setTimeout()이 비동기 방식으로 실행되기 때문에 Hello Again이 먼저 출력됨

내부 함수
function outter(){
    var title = 'coding everybody';  
    function inner(){        
        alert(title); // 외부 함수의 title 지역변수 접근 가능
    }
    inner();
}
outter();

클로저
내부함수가 외부함수의 지역변수에 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는 특성을 의미한다.
ex1)
function outter(){
    var title = 'coding everybody';  
    return function(){        
        alert(title);
    }
}
inner = outter(); // outter 실행
inner(); // outter 실행이 끝나고 inner실행이 되며, title이 소멸되야하지만 소멸되지 않음으로써 coding everybody가 출력됨

ex2)
// js는 기본적으로 Private한 속성을 지원하지 않는데, 클로저의 이러한 특성을 이용해서 Private한 속성을 사용할 수 있게 된다.
function factory_movie(title){
  return { // 객체 반환
    get_title : function(){ // 지역변수 title 사용
      return title;
    },
    set_title : function(_title){ 
      title = _title
    }
  }
}

ghost = factory_movie('Ghost in the shell');
matrix = factory_movie('Matrix');

console.log(ghost.get_title());
console.log(matrix.get_title());

ghost.set_title('공각기동대'); // get, set_title의 title이 동일

console.log(ghost.get_title());
console.log(matrix.get_title());

arguments
